.\" Man page generated from reStructuredText.
.
.TH "PYTHON-ENGINEIO" "1" "Dec 26, 2019" "" "python-engineio"
.SH NAME
python-engineio \- python-engineio Documentation
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.sp
This project implements Python based Engine.IO client and server that can run
standalone or integrated with a variety of Python web frameworks and
applications.
.SH GETTING STARTED
.SS What is Engine.IO?
.sp
Engine.IO is a lightweight transport protocol that enables real\-time
bidirectional event\-based communication between clients (typically, though
not always, web browsers) and a server. The official implementations of the
client and server components are written in JavaScript. This package provides
Python implementations of both, each with standard and \fBasyncio\fP variants.
.sp
The Engine.IO protocol is extremely simple. Once a connection between a client
and a server is established, either side can send "messages" to the other
side. Event handlers provided by the applications on both ends are invoked
when a message is received, or when a connection is established or dropped.
.SS Client Examples
.sp
The example that follows shows a simple Python client:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
import engineio

eio = engineio.Client()

@eio.on(\(aqconnect\(aq)
def on_connect():
    print(\(aqconnection established\(aq)

@eio.on(\(aqmessage\(aq)
def on_message(data):
    print(\(aqmessage received with \(aq, data)
    eio.send({\(aqresponse\(aq: \(aqmy response\(aq})

@eio.on(\(aqdisconnect\(aq)
def on_disconnect():
    print(\(aqdisconnected from server\(aq)

eio.connect(\(aqhttp://localhost:5000\(aq)
eio.wait()
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
And here is a similar client written using the official Engine.IO Javascript
client:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
<script src="/path/to/engine.io.js"></script>
<script>
    var socket = eio(\(aqhttp://localhost:5000\(aq);
    socket.on(\(aqopen\(aq, function() { console.log(\(aqconnection established\(aq); });
    socket.on(\(aqmessage\(aq, function(data) {
        console.log(\(aqmessage received with \(aq + data);
        socket.send({response: \(aqmy response\(aq});
    });
    socket.on(\(aqclose\(aq, function() { console.log(\(aqdisconnected from server\(aq); });
</script>
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Client Features
.INDENT 0.0
.IP \(bu 2
Can connect to other Engine.IO complaint servers besides the one in this package.
.IP \(bu 2
Compatible with Python 2.7 and 3.5+.
.IP \(bu 2
Two versions of the client, one for standard Python and another for \fBasyncio\fP\&.
.IP \(bu 2
Uses an event\-based architecture implemented with decorators that hides the
details of the protocol.
.IP \(bu 2
Implements HTTP long\-polling and WebSocket transports.
.UNINDENT
.SS Server Examples
.sp
The following application is a basic example that uses the Eventlet
asynchronous server:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
import engineio
import eventlet

eio = engineio.Server()
app = engineio.WSGIApp(eio, static_files={
    \(aq/\(aq: {\(aqcontent_type\(aq: \(aqtext/html\(aq, \(aqfilename\(aq: \(aqindex.html\(aq}
})

@eio.on(\(aqconnect\(aq)
def connect(sid, environ):
    print("connect ", sid)

@eio.on(\(aqmessage\(aq)
def message(sid, data):
    print("message ", data)
    eio.send(sid, \(aqreply\(aq)

@eio.on(\(aqdisconnect\(aq)
def disconnect(sid):
    print(\(aqdisconnect \(aq, sid)

if __name__ == \(aq__main__\(aq:
    eventlet.wsgi.server(eventlet.listen((\(aq\(aq, 5000)), app)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Below is a similar application, coded for asyncio (Python 3.5+ only) and the
Uvicorn web server:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
import engineio
import uvicorn

eio = engineio.AsyncServer()
app = engineio.ASGIApp(eio, static_files={
    \(aq/\(aq: {\(aqcontent_type\(aq: \(aqtext/html\(aq, \(aqfilename\(aq: \(aqindex.html\(aq}
})

@eio.on(\(aqconnect\(aq)
def connect(sid, environ):
    print("connect ", sid)

@eio.on(\(aqmessage\(aq)
async def message(sid, data):
    print("message ", data)
    await eio.send(sid, \(aqreply\(aq)

@eio.on(\(aqdisconnect\(aq)
def disconnect(sid):
    print(\(aqdisconnect \(aq, sid)

if __name__ == \(aq__main__\(aq:
    uvicorn.run(\(aq127.0.0.1\(aq, 5000)
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Server Features
.INDENT 0.0
.IP \(bu 2
Can accept clients running other complaint Engine.IO clients besides the one in this
package.
.IP \(bu 2
Compatible with Python 2.7 and Python 3.5+.
.IP \(bu 2
Two versions of the server, one for standard Python and another for \fBasyncio\fP\&.
.IP \(bu 2
Supports large number of clients even on modest hardware due to being
asynchronous.
.IP \(bu 2
Can be hosted on any \fI\%WSGI\fP and
\fI\%ASGI\fP web servers includind
\fI\%Gunicorn\fP, \fI\%Uvicorn\fP,
\fI\%eventlet\fP and \fI\%gevent\fP\&.
.IP \(bu 2
Can be integrated with WSGI applications written in frameworks such as Flask, Django,
etc.
.IP \(bu 2
Can be integrated with \fI\%aiohttp\fP,
\fI\%sanic\fP and \fI\%tornado\fP
\fBasyncio\fP applications.
.IP \(bu 2
Uses an event\-based architecture implemented with decorators that hides the
details of the protocol.
.IP \(bu 2
Implements HTTP long\-polling and WebSocket transports.
.IP \(bu 2
Supports XHR2 and XHR browsers as clients.
.IP \(bu 2
Supports text and binary messages.
.IP \(bu 2
Supports gzip and deflate HTTP compression.
.IP \(bu 2
Configurable CORS responses to avoid cross\-origin problems with browsers.
.UNINDENT
.SH THE ENGINE.IO CLIENT
.sp
This package contains two Engine.IO clients:
.INDENT 0.0
.IP \(bu 2
The \fBengineio.Client()\fP class creates a client compatible with the
standard Python library.
.IP \(bu 2
The \fBengineio.AsyncClient()\fP class creates a client compatible with
the \fBasyncio\fP package.
.UNINDENT
.sp
The methods in the two clients are the same, with the only difference that in
the \fBasyncio\fP client most methods are implemented as coroutines.
.SS Installation
.sp
To install the standard Python client along with its dependencies, use the
following command:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
pip install "python\-engineio[client]"
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If instead you plan on using the \fBasyncio\fP client, then use this:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
pip install "python\-engineio[asyncio_client]"
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Creating a Client Instance
.sp
To instantiate an Engine.IO client, simply create an instance of the
appropriate client class:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
import engineio

# standard Python
eio = engineio.Client()

# asyncio
eio = engineio.AsyncClient()
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Defining Event Handlers
.sp
To responds to events triggered by the connection or the server, event Handler
functions must be defined using the \fBon\fP decorator:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
@eio.on(\(aqconnect\(aq)
def on_connect():
    print(\(aqI\(aqm connected!\(aq)

@eio.on(\(aqmessage\(aq)
def on_message(data):
    print(\(aqI received a message!\(aq)

@eio.on(\(aqdisconnect\(aq)
def on_disconnect():
    print(\(aqI\(aqm disconnected!\(aq)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
For the \fBasyncio\fP server, event handlers can be regular functions as above,
or can also be coroutines:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
@eio.on(\(aqmessage\(aq)
async def on_message(data):
    print(\(aqI received a message!\(aq)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The argument given to the \fBon\fP decorator is the event name. The events that
are supported are \fBconnect\fP, \fBmessage\fP and \fBdisconnect\fP\&. Note that the
\fBdisconnect\fP handler is invoked for application initiated disconnects,
server initiated disconnects, or accidental disconnects, for example due to
networking failures.
.sp
The \fBdata\fP argument passed to the \fB\(aqmessage\(aq\fP event handler contains
application\-specific data provided by the server with the event.
.SS Connecting to a Server
.sp
The connection to a server is established by calling the \fBconnect()\fP
method:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
eio.connect(\(aqhttp://localhost:5000\(aq)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
In the case of the \fBasyncio\fP client, the method is a coroutine:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
await eio.connect(\(aqhttp://localhost:5000\(aq)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Upon connection, the server assigns the client a unique session identifier.
The applicaction can find this identifier in the \fBsid\fP attribute:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
print(\(aqmy sid is\(aq, eio.sid)
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Sending Messages
.sp
The client can send a message to the server using the \fBsend()\fP method:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
eio.send({\(aqfoo\(aq: \(aqbar\(aq})
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Or in the case of \fBasyncio\fP, as a coroutine:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
await eio.send({\(aqfoo\(aq: \(aqbar\(aq})
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The single argument provided to the method is the data that is passed on
to the server. The data can be of type \fBstr\fP, \fBbytes\fP, \fBdict\fP or
\fBlist\fP\&. The data included inside dictionaries and lists is also
constrained to these types.
.sp
The \fBsend()\fP method can be invoked inside an event handler as a response
to a server event, or in any other part of the application, including in
background tasks.
.SS Disconnecting from the Server
.sp
At any time the client can request to be disconnected from the server by
invoking the \fBdisconnect()\fP method:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
eio.disconnect()
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
For the \fBasyncio\fP client this is a coroutine:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
await eio.disconnect()
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Managing Background Tasks
.sp
When a client connection to the server is established, a few background
tasks will be spawned to keep the connection alive and handle incoming
events. The application running on the main thread is free to do any
work, as this is not going to prevent the functioning of the Engine.IO
client.
.sp
If the application does not have anything to do in the main thread and
just wants to wait until the connection ends, it can call the \fBwait()\fP
method:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
eio.wait()
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Or in the \fBasyncio\fP version:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
await eio.wait()
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
For the convenience of the application, a helper function is
provided to start a custom background task:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
def my_background_task(my_argument)
    # do some background work here!
    pass

eio.start_background_task(my_background_task, 123)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The arguments passed to this method are the background function and any
positional or keyword arguments to invoke the function with.
.sp
Here is the \fBasyncio\fP version:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
async def my_background_task(my_argument)
    # do some background work here!
    pass

eio.start_background_task(my_background_task, 123)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Note that this function is not a coroutine, since it does not wait for the
background function to end, but the background function is.
.sp
The \fBsleep()\fP method is a second convenience function that is provided for
the benefit of applications working with background tasks of their own:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
eio.sleep(2)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Or for \fBasyncio\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
await eio.sleep(2)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The single argument passed to the method is the number of seconds to sleep
for.
.SH THE ENGINE.IO SERVER
.sp
This package contains two Engine.IO servers:
.INDENT 0.0
.IP \(bu 2
The \fBengineio.Server()\fP class creates a server compatible with the
standard Python library.
.IP \(bu 2
The \fBengineio.AsyncServer()\fP class creates a server compatible with
the \fBasyncio\fP package.
.UNINDENT
.sp
The methods in the two servers are the same, with the only difference that in
the \fBasyncio\fP server most methods are implemented as coroutines.
.SS Installation
.sp
To install the Python Engine.IO server use the following command:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
pip install "python\-engineio"
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
In addition to the server, you will need to select an asynchronous framework
or server to use along with it. The list of supported packages is covered
in the \fI\%Deployment Strategies\fP section.
.SS Creating a Server Instance
.sp
An Engine.IO server is an instance of class \fBengineio.Server\fP\&. This
instance can be transformed into a standard WSGI application by wrapping it
with the \fBengineio.WSGIApp\fP class:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
import engineio

# create a Engine.IO server
eio = engineio.Server()

# wrap with a WSGI application
app = engineio.WSGIApp(eio)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
For asyncio based servers, the \fBengineio.AsyncServer\fP class provides
the same functionality, but in a coroutine friendly format. If desired, The
\fBengineio.ASGIApp\fP class can transform the server into a standard
ASGI application:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# create a Engine.IO server
eio = engineio.AsyncServer()

# wrap with ASGI application
app = engineio.ASGIApp(eio)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
These two wrappers can also act as middlewares, forwarding any traffic that is
not intended to the Engine.IO server to another application. This allows
Engine.IO servers to integrate easily into existing WSGI or ASGI applications:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
from wsgi import app  # a Flask, Django, etc. application
app = engineio.WSGIApp(eio, app)
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Serving Static Files
.sp
The Engine.IO server can be configured to serve static files to clients. This
is particularly useful to deliver HTML, CSS and JavaScript files to clients
when this package is used without a companion web framework.
.sp
Static files are configured with a Python dictionary in which each key/value
pair is a static file mapping rule. In its simplest form, this dictionary has
one or more static file URLs as keys, and the corresponding files in the server
as values:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
static_files = {
    \(aq/\(aq: \(aqlatency.html\(aq,
    \(aq/static/engine.io.js\(aq: \(aqstatic/engine.io.js\(aq,
    \(aq/static/style.css\(aq: \(aqstatic/style.css\(aq,
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
With this example configuration, when the server receives a request for \fB/\fP
(the root URL) it will return the contents of the file \fBlatency.html\fP in the
current directory, and will assign a content type based on the file extension,
in this case \fBtext/html\fP\&.
.sp
Files with the \fB\&.html\fP, \fB\&.css\fP, \fB\&.js\fP, \fB\&.json\fP, \fB\&.jpg\fP, \fB\&.png\fP,
\fB\&.gif\fP and \fB\&.txt\fP file extensions are automatically recognized and
assigned the correct content type. For files with other file extensions or
with no file extension, the \fBapplication/octet\-stream\fP content type is used
as a default.
.sp
If desired, an explicit content type for a static file can be given as follows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
static_files = {
    \(aq/\(aq: {\(aqfilename\(aq: \(aqlatency.html\(aq, \(aqcontent_type\(aq: \(aqtext/plain\(aq},
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
It is also possible to configure an entire directory in a single rule, so that all
the files in it are served as static files:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
static_files = {
    \(aq/static\(aq: \(aq./public\(aq,
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
In this example any files with URLs starting with \fB/static\fP will be served
directly from the \fBpublic\fP folder in the current directory, so for example,
the URL \fB/static/index.html\fP will return local file \fB\&./public/index.html\fP
and the URL \fB/static/css/styles.css\fP will return local file
\fB\&./public/css/styles.css\fP\&.
.sp
If a URL that ends in a \fB/\fP is requested, then a default filename of
\fBindex.html\fP is appended to it. In the previous example, a request for the
\fB/static/\fP URL would return local file \fB\&./public/index.html\fP\&. The default
filename to serve for slash\-ending URLs can be set in the static files
dictionary with an empty key:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
static_files = {
    \(aq/static\(aq: \(aq./public\(aq,
    \(aq\(aq: \(aqimage.gif\(aq,
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
With this configuration, a request for \fB/static/\fP would return
local file \fB\&./public/image.gif\fP\&. A non\-standard content type can also be
specified if needed:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
static_files = {
    \(aq/static\(aq: \(aq./public\(aq,
    \(aq\(aq: {\(aqfilename\(aq: \(aqimage.gif\(aq, \(aqcontent_type\(aq: \(aqtext/plain\(aq},
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The static file configuration dictionary is given as the \fBstatic_files\fP
argument to the \fBengineio.WSGIApp\fP or \fBengineio.ASGIApp\fP classes:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# for standard WSGI applications
eio = engineio.Server()
app = engineio.WSGIApp(eio, static_files=static_files)

# for asyncio\-based ASGI applications
eio = engineio.AsyncServer()
app = engineio.ASGIApp(eio, static_files=static_files)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The routing precedence in these two classes is as follows:
.INDENT 0.0
.IP \(bu 2
First, the path is checked against the Engine.IO path.
.IP \(bu 2
Next, the path is checked against the static file configuration, if present.
.IP \(bu 2
If the path did not match the Engine.IO path or any static file, control is
passed to the secondary application if configured, else a 404 error is
returned.
.UNINDENT
.sp
Note: static file serving is intended for development use only, and as such
it lacks important features such as caching. Do not use in a production
environment.
.SS Defining Event Handlers
.sp
To responds to events triggered by the connection or the client, event Handler
functions must be defined using the \fBon\fP decorator:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
@eio.on(\(aqconnect\(aq)
def on_connect(sid):
    print(\(aqA client connected!\(aq)

@eio.on(\(aqmessage\(aq)
def on_message(sid, data):
    print(\(aqI received a message!\(aq)

@eio.on(\(aqdisconnect\(aq)
def on_disconnect(sid):
    print(\(aqClient disconnected!\(aq)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
For the \fBasyncio\fP server, event handlers can be regular functions as above,
or can also be coroutines:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
@eio.on(\(aqmessage\(aq)
async def on_message(sid, data):
    print(\(aqI received a message!\(aq)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The argument given to the \fBon\fP decorator is the event name. The events that
are supported are \fBconnect\fP, \fBmessage\fP and \fBdisconnect\fP\&. Note that the
\fBdisconnect\fP handler is invoked for client initiated disconnects,
server initiated disconnects, or accidental disconnects, for example due to
networking failures.
.sp
The \fBsid\fP argument passed into all the event handlers is a connection
identifier for the client. All the events from a client will use the same
\fBsid\fP value.
.sp
The \fBdata\fP argument passed to the \fB\(aqmessage\(aq\fP event handler contains
application\-specific data provided by the client with the event.
.SS Sending Messages
.sp
The server can send a message to any client using the \fBsend()\fP method:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
eio.send(sid, {\(aqfoo\(aq: \(aqbar\(aq})
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Or in the case of \fBasyncio\fP, as a coroutine:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
await eio.send(sid, {\(aqfoo\(aq: \(aqbar\(aq})
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The first argument provided to the method is the connection identifier for
the recipient client. The second argument is the data that is passed on
to the server. The data can be of type \fBstr\fP, \fBbytes\fP, \fBdict\fP or
\fBlist\fP\&. The data included inside dictionaries and lists is also
constrained to these types.
.sp
The \fBsend()\fP method can be invoked inside an event handler as a response
to a client event, or in any other part of the application, including in
background tasks.
.SS User Sessions
.sp
The server can maintain application\-specific information in a user session
dedicated to each connected client. Applications can use the user session to
write any details about the user that need to be preserved throughout the life
of the connection, such as usernames or user ids.
.sp
The \fBsave_session()\fP and \fBget_session()\fP methods are used to store and
retrieve information in the user session:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
@eio.on(\(aqconnect\(aq)
def on_connect(sid, environ):
    username = authenticate_user(environ)
    eio.save_session(sid, {\(aqusername\(aq: username})

@eio.on(\(aqmessage\(aq)
def on_message(sid, data):
    session = eio.get_session(sid)
    print(\(aqmessage from \(aq, session[\(aqusername\(aq])
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
For the \fBasyncio\fP server, these methods are coroutines:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
@eio.on(\(aqconnect\(aq)
async def on_connect(sid, environ):
    username = authenticate_user(environ)
    await eio.save_session(sid, {\(aqusername\(aq: username})

@eio.on(\(aqmessage\(aq)
async def on_message(sid, data):
    session = await eio.get_session(sid)
    print(\(aqmessage from \(aq, session[\(aqusername\(aq])
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The session can also be manipulated with the \fIsession()\fP context manager:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
@eio.on(\(aqconnect\(aq)
def on_connect(sid, environ):
    username = authenticate_user(environ)
    with eio.session(sid) as session:
        session[\(aqusername\(aq] = username

@eio.on(\(aqmessage\(aq)
def on_message(sid, data):
    with eio.session(sid) as session:
        print(\(aqmessage from \(aq, session[\(aqusername\(aq])
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
For the \fBasyncio\fP server, an asynchronous context manager is used:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
@eio.on(\(aqconnect\(aq)
def on_connect(sid, environ):
    username = authenticate_user(environ)
    async with eio.session(sid) as session:
        session[\(aqusername\(aq] = username

@eio.on(\(aqmessage\(aq)
def on_message(sid, data):
    async with eio.session(sid) as session:
        print(\(aqmessage from \(aq, session[\(aqusername\(aq])
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Note: the contents of the user session are destroyed when the client
disconnects.
.SS Disconnecting a Client
.sp
At any time the server can disconnect a client from the server by invoking the
\fBdisconnect()\fP method and passing the \fBsid\fP value assigned to the client:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
eio.disconnect(sid)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
For the \fBasyncio\fP client this is a coroutine:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
await eio.disconnect(sid)
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Managing Background Tasks
.sp
For the convenience of the application, a helper function is provided to
start a custom background task:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
def my_background_task(my_argument)
    # do some background work here!
    pass

eio.start_background_task(my_background_task, 123)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The arguments passed to this method are the background function and any
positional or keyword arguments to invoke the function with.
.sp
Here is the \fBasyncio\fP version:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
async def my_background_task(my_argument)
    # do some background work here!
    pass

eio.start_background_task(my_background_task, 123)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Note that this function is not a coroutine, since it does not wait for the
background function to end, but the background function is.
.sp
The \fBsleep()\fP method is a second convenience function that is provided for
the benefit of applications working with background tasks of their own:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
eio.sleep(2)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Or for \fBasyncio\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
await eio.sleep(2)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The single argument passed to the method is the number of seconds to sleep
for.
.SS Deployment Strategies
.sp
The following sections describe a variety of deployment strategies for
Engine.IO servers.
.SS aiohttp
.sp
\fI\%aiohttp\fP provides a framework with support
for HTTP and WebSocket, based on asyncio. Support for this framework is limited
to Python 3.5 and newer.
.sp
Instances of class \fBengineio.AsyncServer\fP will automatically use aiohttp
for asynchronous operations if the library is installed. To request its use
explicitly, the \fBasync_mode\fP option can be given in the constructor:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
eio = engineio.AsyncServer(async_mode=\(aqaiohttp\(aq)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
A server configured for aiohttp must be attached to an existing application:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
app = web.Application()
eio.attach(app)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The aiohttp application can define regular routes that will coexist with the
Engine.IO server. A typical pattern is to add routes that serve a client
application and any associated static files.
.sp
The aiohttp application is then executed in the usual manner:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
if __name__ == \(aq__main__\(aq:
    web.run_app(app)
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Tornado
.sp
\fI\%Tornado\fP is a web framework with support
for HTTP and WebSocket. Support for this framework requires Python 3.5 and
newer. Only Tornado version 5 and newer are supported, thanks to its tight
integration with asyncio.
.sp
Instances of class \fBengineio.AsyncServer\fP will automatically use tornado
for asynchronous operations if the library is installed. To request its use
explicitly, the \fBasync_mode\fP option can be given in the constructor:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
eio = engineio.AsyncServer(async_mode=\(aqtornado\(aq)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
A server configured for tornado must include a request handler for
Engine.IO:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
app = tornado.web.Application(
    [
        (r"/engine.io/", engineio.get_tornado_handler(eio)),
    ],
    # ... other application options
)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The tornado application can define other routes that will coexist with the
Engine.IO server. A typical pattern is to add routes that serve a client
application and any associated static files.
.sp
The tornado application is then executed in the usual manner:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
app.listen(port)
tornado.ioloop.IOLoop.current().start()
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Sanic
.sp
\fI\%Sanic\fP is a very efficient asynchronous web
server for Python 3.5 and newer.
.sp
Instances of class \fBengineio.AsyncServer\fP will automatically use Sanic for
asynchronous operations if the framework is installed. To request its use
explicitly, the \fBasync_mode\fP option can be given in the constructor:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
eio = engineio.AsyncServer(async_mode=\(aqsanic\(aq)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
A server configured for Sanic must be attached to an existing application:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
app = Sanic()
eio.attach(app)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The Sanic application can define regular routes that will coexist with the
Engine.IO server. A typical pattern is to add routes that serve a client
application and any associated static files to this application.
.sp
The Sanic application is then executed in the usual manner:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
if __name__ == \(aq__main__\(aq:
    app.run()
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
It has been reported that the CORS support provided by the Sanic extension
\fI\%sanic\-cors\fP is incompatible with
this package\(aqs own support for this protocol. To disable CORS support in this
package and let Sanic take full control, initialize the server as follows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
eio = engineio.AsyncServer(async_mode=\(aqsanic\(aq, cors_allowed_origins=[])
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
On the Sanic side you will need to enable the \fICORS_SUPPORTS_CREDENTIALS\fP
setting in addition to any other configuration that you use:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
app.config[\(aqCORS_SUPPORTS_CREDENTIALS\(aq] = True
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Uvicorn, Daphne, and other ASGI servers
.sp
The \fBengineio.ASGIApp\fP class is an ASGI compatible application that can
forward Engine.IO traffic to an \fBengineio.AsyncServer\fP instance:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
eio = engineio.AsyncServer(async_mode=\(aqasgi\(aq)
app = engineio.ASGIApp(eio)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The application can then be deployed with any ASGI compatible web server.
.SS Eventlet
.sp
\fI\%Eventlet\fP is a high performance concurrent networking
library for Python 2 and 3 that uses coroutines, enabling code to be written in
the same style used with the blocking standard library functions. An Engine.IO
server deployed with eventlet has access to the long\-polling and WebSocket
transports.
.sp
Instances of class \fBengineio.Server\fP will automatically use eventlet for
asynchronous operations if the library is installed. To request its use
explicitly, the \fBasync_mode\fP option can be given in the constructor:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
eio = engineio.Server(async_mode=\(aqeventlet\(aq)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
A server configured for eventlet is deployed as a regular WSGI application
using the provided \fBengineio.WSGIApp\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
app = engineio.WSGIApp(eio)
import eventlet
eventlet.wsgi.server(eventlet.listen((\(aq\(aq, 8000)), app)
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Eventlet with Gunicorn
.sp
An alternative to running the eventlet WSGI server as above is to use
\fI\%gunicorn\fP, a fully featured pure Python web server. The
command to launch the application under gunicorn is shown below:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ gunicorn \-k eventlet \-w 1 module:app
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Due to limitations in its load balancing algorithm, gunicorn can only be used
with one worker process, so the \fB\-w 1\fP option is required. Note that a
single eventlet worker can handle a large number of concurrent clients.
.sp
Another limitation when using gunicorn is that the WebSocket transport is not
available, because this transport it requires extensions to the WSGI standard.
.sp
Note: Eventlet provides a \fBmonkey_patch()\fP function that replaces all the
blocking functions in the standard library with equivalent asynchronous
versions. While python\-engineio does not require monkey patching, other
libraries such as database drivers are likely to require it.
.SS Gevent
.sp
\fI\%Gevent\fP is another asynchronous framework based on
coroutines, very similar to eventlet. An Engine.IO server deployed with
gevent has access to the long\-polling transport. If project
\fI\%gevent\-websocket\fP is
installed, the WebSocket transport is also available. Note that when using the
uWSGI server, the native WebSocket implementation of uWSGI can be used instead
of gevent\-websocket (see next section for details on this).
.sp
Instances of class \fBengineio.Server\fP will automatically use gevent for
asynchronous operations if the library is installed and eventlet is not
installed. To request gevent to be selected explicitly, the \fBasync_mode\fP
option can be given in the constructor:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# gevent alone or with gevent\-websocket
eio = engineio.Server(async_mode=\(aqgevent\(aq)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
A server configured for gevent is deployed as a regular WSGI application
using the provided \fBengineio.WSGIApp\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
from gevent import pywsgi
app = engineio.WSGIApp(eio)
pywsgi.WSGIServer((\(aq\(aq, 8000), app).serve_forever()
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If the WebSocket transport is installed, then the server must be started as
follows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
from gevent import pywsgi
from geventwebsocket.handler import WebSocketHandler
app = engineio.WSGIApp(eio)
pywsgi.WSGIServer((\(aq\(aq, 8000), app,
                  handler_class=WebSocketHandler).serve_forever()
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Gevent with Gunicorn
.sp
An alternative to running the gevent WSGI server as above is to use
\fI\%gunicorn\fP, a fully featured pure Python web server. The
command to launch the application under gunicorn is shown below:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ gunicorn \-k gevent \-w 1 module:app
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Or to include WebSocket:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ gunicorn \-k geventwebsocket.gunicorn.workers.GeventWebSocketWorker \-w 1 module: app
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Same as with eventlet, due to limitations in its load balancing algorithm,
gunicorn can only be used with one worker process, so the \fB\-w 1\fP option is
required. Note that a single gevent worker can handle a large number of
concurrent clients.
.sp
Note: Gevent provides a \fBmonkey_patch()\fP function that replaces all the
blocking functions in the standard library with equivalent asynchronous
versions. While python\-engineio does not require monkey patching, other
libraries such as database drivers are likely to require it.
.SS uWSGI
.sp
When using the uWSGI server in combination with gevent, the Engine.IO server
can take advantage of uWSGI\(aqs native WebSocket support.
.sp
Instances of class \fBengineio.Server\fP will automatically use this option for
asynchronous operations if both gevent and uWSGI are installed and eventlet is
not installed. To request this asynchoronous mode explicitly, the
\fBasync_mode\fP option can be given in the constructor:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# gevent with uWSGI
eio = engineio.Server(async_mode=\(aqgevent_uwsgi\(aq)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
A complete explanation of the configuration and usage of the uWSGI server is
beyond the scope of this documentation. The uWSGI server is a fairly complex
package that provides a large and comprehensive set of options. It must be
compiled with WebSocket and SSL support for the WebSocket transport to be
available. As way of an introduction, the following command starts a uWSGI
server for the \fBlatency.py\fP example on port 5000:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ uwsgi \-\-http :5000 \-\-gevent 1000 \-\-http\-websockets \-\-master \-\-wsgi\-file latency.py \-\-callable app
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Standard Threads
.sp
While not comparable to eventlet and gevent in terms of performance,
the Engine.IO server can also be configured to work with multi\-threaded web
servers that use standard Python threads. This is an ideal setup to use with
development servers such as \fI\%Werkzeug\fP\&. Only the
long\-polling transport is currently available when using standard threads.
.sp
Instances of class \fBengineio.Server\fP will automatically use the threading
mode if neither eventlet nor gevent are not installed. To request the
threading mode explicitly, the \fBasync_mode\fP option can be given in the
constructor:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
eio = engineio.Server(async_mode=\(aqthreading\(aq)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
A server configured for threading is deployed as a regular web application,
using any WSGI complaint multi\-threaded server. The example below deploys an
Engine.IO application combined with a Flask web application, using Flask\(aqs
development web server based on Werkzeug:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
eio = engineio.Server(async_mode=\(aqthreading\(aq)
app = Flask(__name__)
app.wsgi_app = engineio.WSGIApp(eio, app.wsgi_app)

# ... Engine.IO and Flask handler functions ...

if __name__ == \(aq__main__\(aq:
    app.run(threaded=True)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
When using the threading mode, it is important to ensure that the WSGI server
can handle multiple concurrent requests using threads, since a client can have
up to two outstanding requests at any given time. The Werkzeug server is
single\-threaded by default, so the \fBthreaded=True\fP option is required.
.sp
Note that servers that use worker processes instead of threads, such as
gunicorn, do not support an Engine.IO server configured in threading mode.
.SS Scalability Notes
.sp
Engine.IO is a stateful protocol, which makes horizontal scaling more
difficult. To deploy a cluster of Engine.IO processes hosted on one or
multiple servers the following conditions must be met:
.INDENT 0.0
.IP \(bu 2
Each Engine.IO server process must be able to handle multiple requests
concurrently. This is required because long\-polling clients send two
requests in parallel. Worker processes that can only handle one request at a
time are not supported.
.IP \(bu 2
The load balancer must be configured to always forward requests from a client
to the same process. Load balancers call this \fIsticky sessions\fP, or
\fIsession affinity\fP\&.
.UNINDENT
.SS Cross\-Origin Controls
.sp
For security reasons, this server enforces a same\-origin policy by default. In
practical terms, this means the following:
.INDENT 0.0
.IP \(bu 2
If an incoming HTTP or WebSocket request includes the \fBOrigin\fP header,
this header must match the scheme and host of the connection URL. In case
of a mismatch, a 400 status code response is returned and the connection is
rejected.
.IP \(bu 2
No restrictions are imposed on incoming requests that do not include the
\fBOrigin\fP header.
.UNINDENT
.sp
If necessary, the \fBcors_allowed_origins\fP option can be used to allow other
origins. This argument can be set to a string to set a single allowed origin, or
to a list to allow multiple origins. A special value of \fB\(aq*\(aq\fP can be used to
instruct the server to allow all origins, but this should be done with care, as
this could make the server vulnerable to Cross\-Site Request Forgery (CSRF)
attacks.
.SH API REFERENCE
.SS \fBClient\fP class
.INDENT 0.0
.TP
.B class engineio.Client(logger=False, json=None, request_timeout=5, ssl_verify=True)
An Engine.IO client.
.sp
This class implements a fully compliant Engine.IO web client with support
for websocket and long\-polling transports.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBlogger\fP \-\- To enable logging set to \fBTrue\fP or pass a logger object to
use. To disable logging set to \fBFalse\fP\&. The default is
\fBFalse\fP\&.
.IP \(bu 2
\fBjson\fP \-\- An alternative json module to use for encoding and decoding
packets. Custom json modules must have \fBdumps\fP and \fBloads\fP
functions that are compatible with the standard library
versions.
.IP \(bu 2
\fBrequest_timeout\fP \-\- A timeout in seconds for requests. The default is
5 seconds.
.IP \(bu 2
\fBssl_verify\fP \-\- \fBTrue\fP to verify SSL certificates, or \fBFalse\fP to
skip SSL certificate verification, allowing
connections to servers with self signed certificates.
The default is \fBTrue\fP\&.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B connect(url, headers={}, transports=None, engineio_path=\(aqengine.io\(aq)
Connect to an Engine.IO server.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBurl\fP \-\- The URL of the Engine.IO server. It can include custom
query string parameters if required by the server.
.IP \(bu 2
\fBheaders\fP \-\- A dictionary with custom headers to send with the
connection request.
.IP \(bu 2
\fBtransports\fP \-\- The list of allowed transports. Valid transports
are \fB\(aqpolling\(aq\fP and \fB\(aqwebsocket\(aq\fP\&. If not
given, the polling transport is connected first,
then an upgrade to websocket is attempted.
.IP \(bu 2
\fBengineio_path\fP \-\- The endpoint where the Engine.IO server is
installed. The default value is appropriate for
most cases.
.UNINDENT
.UNINDENT
.sp
Example usage:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
eio = engineio.Client()
eio.connect(\(aqhttp://localhost:5000\(aq)
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B create_event(*args, **kwargs)
Create an event object.
.UNINDENT
.INDENT 7.0
.TP
.B create_queue(*args, **kwargs)
Create a queue object.
.UNINDENT
.INDENT 7.0
.TP
.B disconnect(abort=False)
Disconnect from the server.
.INDENT 7.0
.TP
.B Parameters
\fBabort\fP \-\- If set to \fBTrue\fP, do not wait for background tasks
associated with the connection to end.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B on(event, handler=None)
Register an event handler.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBevent\fP \-\- The event name. Can be \fB\(aqconnect\(aq\fP, \fB\(aqmessage\(aq\fP or
\fB\(aqdisconnect\(aq\fP\&.
.IP \(bu 2
\fBhandler\fP \-\- The function that should be invoked to handle the
event. When this parameter is not given, the method
acts as a decorator for the handler function.
.UNINDENT
.UNINDENT
.sp
Example usage:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
# as a decorator:
@eio.on(\(aqconnect\(aq)
def connect_handler():
    print(\(aqConnection request\(aq)

# as a method:
def message_handler(msg):
    print(\(aqReceived message: \(aq, msg)
    eio.send(\(aqresponse\(aq)
eio.on(\(aqmessage\(aq, message_handler)
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B send(data, binary=None)
Send a message to a client.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBdata\fP \-\- The data to send to the client. Data can be of type
\fBstr\fP, \fBbytes\fP, \fBlist\fP or \fBdict\fP\&. If a \fBlist\fP
or \fBdict\fP, the data will be serialized as JSON.
.IP \(bu 2
\fBbinary\fP \-\- \fBTrue\fP to send packet as binary, \fBFalse\fP to send
as text. If not given, unicode (Python 2) and str
(Python 3) are sent as text, and str (Python 2) and
bytes (Python 3) are sent as binary.
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B sleep(seconds=0)
Sleep for the requested amount of time.
.UNINDENT
.INDENT 7.0
.TP
.B start_background_task(target, *args, **kwargs)
Start a background task.
.sp
This is a utility function that applications can use to start a
background task.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBtarget\fP \-\- the target function to execute.
.IP \(bu 2
\fBargs\fP \-\- arguments to pass to the function.
.IP \(bu 2
\fBkwargs\fP \-\- keyword arguments to pass to the function.
.UNINDENT
.UNINDENT
.sp
This function returns an object compatible with the \fIThread\fP class in
the Python standard library. The \fIstart()\fP method on this object is
already called by this function.
.UNINDENT
.INDENT 7.0
.TP
.B transport()
Return the name of the transport currently in use.
.sp
The possible values returned by this function are \fB\(aqpolling\(aq\fP and
\fB\(aqwebsocket\(aq\fP\&.
.UNINDENT
.INDENT 7.0
.TP
.B wait()
Wait until the connection with the server ends.
.sp
Client applications can use this function to block the main thread
during the life of the connection.
.UNINDENT
.UNINDENT
.SS \fBAsyncClient\fP class
.INDENT 0.0
.TP
.B class engineio.AsyncClient(logger=False, json=None, request_timeout=5, ssl_verify=True)
An Engine.IO client for asyncio.
.sp
This class implements a fully compliant Engine.IO web client with support
for websocket and long\-polling transports, compatible with the asyncio
framework on Python 3.5 or newer.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBlogger\fP \-\- To enable logging set to \fBTrue\fP or pass a logger object to
use. To disable logging set to \fBFalse\fP\&. The default is
\fBFalse\fP\&.
.IP \(bu 2
\fBjson\fP \-\- An alternative json module to use for encoding and decoding
packets. Custom json modules must have \fBdumps\fP and \fBloads\fP
functions that are compatible with the standard library
versions.
.IP \(bu 2
\fBrequest_timeout\fP \-\- A timeout in seconds for requests. The default is
5 seconds.
.IP \(bu 2
\fBssl_verify\fP \-\- \fBTrue\fP to verify SSL certificates, or \fBFalse\fP to
skip SSL certificate verification, allowing
connections to servers with self signed certificates.
The default is \fBTrue\fP\&.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B connect(url, headers={}, transports=None, engineio_path=\(aqengine.io\(aq)
Connect to an Engine.IO server.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBurl\fP \-\- The URL of the Engine.IO server. It can include custom
query string parameters if required by the server.
.IP \(bu 2
\fBheaders\fP \-\- A dictionary with custom headers to send with the
connection request.
.IP \(bu 2
\fBtransports\fP \-\- The list of allowed transports. Valid transports
are \fB\(aqpolling\(aq\fP and \fB\(aqwebsocket\(aq\fP\&. If not
given, the polling transport is connected first,
then an upgrade to websocket is attempted.
.IP \(bu 2
\fBengineio_path\fP \-\- The endpoint where the Engine.IO server is
installed. The default value is appropriate for
most cases.
.UNINDENT
.UNINDENT
.sp
Note: this method is a coroutine.
.sp
Example usage:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
eio = engineio.Client()
await eio.connect(\(aqhttp://localhost:5000\(aq)
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B create_event()
Create an event object.
.UNINDENT
.INDENT 7.0
.TP
.B create_queue()
Create a queue object.
.UNINDENT
.INDENT 7.0
.TP
.B disconnect(abort=False)
Disconnect from the server.
.INDENT 7.0
.TP
.B Parameters
\fBabort\fP \-\- If set to \fBTrue\fP, do not wait for background tasks
associated with the connection to end.
.UNINDENT
.sp
Note: this method is a coroutine.
.UNINDENT
.INDENT 7.0
.TP
.B on(event, handler=None)
Register an event handler.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBevent\fP \-\- The event name. Can be \fB\(aqconnect\(aq\fP, \fB\(aqmessage\(aq\fP or
\fB\(aqdisconnect\(aq\fP\&.
.IP \(bu 2
\fBhandler\fP \-\- The function that should be invoked to handle the
event. When this parameter is not given, the method
acts as a decorator for the handler function.
.UNINDENT
.UNINDENT
.sp
Example usage:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
# as a decorator:
@eio.on(\(aqconnect\(aq)
def connect_handler():
    print(\(aqConnection request\(aq)

# as a method:
def message_handler(msg):
    print(\(aqReceived message: \(aq, msg)
    eio.send(\(aqresponse\(aq)
eio.on(\(aqmessage\(aq, message_handler)
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B send(data, binary=None)
Send a message to a client.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBdata\fP \-\- The data to send to the client. Data can be of type
\fBstr\fP, \fBbytes\fP, \fBlist\fP or \fBdict\fP\&. If a \fBlist\fP
or \fBdict\fP, the data will be serialized as JSON.
.IP \(bu 2
\fBbinary\fP \-\- \fBTrue\fP to send packet as binary, \fBFalse\fP to send
as text. If not given, unicode (Python 2) and str
(Python 3) are sent as text, and str (Python 2) and
bytes (Python 3) are sent as binary.
.UNINDENT
.UNINDENT
.sp
Note: this method is a coroutine.
.UNINDENT
.INDENT 7.0
.TP
.B sleep(seconds=0)
Sleep for the requested amount of time.
.sp
Note: this method is a coroutine.
.UNINDENT
.INDENT 7.0
.TP
.B start_background_task(target, *args, **kwargs)
Start a background task.
.sp
This is a utility function that applications can use to start a
background task.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBtarget\fP \-\- the target function to execute.
.IP \(bu 2
\fBargs\fP \-\- arguments to pass to the function.
.IP \(bu 2
\fBkwargs\fP \-\- keyword arguments to pass to the function.
.UNINDENT
.UNINDENT
.sp
This function returns an object compatible with the \fIThread\fP class in
the Python standard library. The \fIstart()\fP method on this object is
already called by this function.
.sp
Note: this method is a coroutine.
.UNINDENT
.INDENT 7.0
.TP
.B transport()
Return the name of the transport currently in use.
.sp
The possible values returned by this function are \fB\(aqpolling\(aq\fP and
\fB\(aqwebsocket\(aq\fP\&.
.UNINDENT
.INDENT 7.0
.TP
.B wait()
Wait until the connection with the server ends.
.sp
Client applications can use this function to block the main thread
during the life of the connection.
.sp
Note: this method is a coroutine.
.UNINDENT
.UNINDENT
.SS \fBServer\fP class
.INDENT 0.0
.TP
.B class engineio.Server(async_mode=None, ping_timeout=60, ping_interval=25, max_http_buffer_size=100000000, allow_upgrades=True, http_compression=True, compression_threshold=1024, cookie=\(aqio\(aq, cors_allowed_origins=None, cors_credentials=True, logger=False, json=None, async_handlers=True, monitor_clients=None, **kwargs)
An Engine.IO server.
.sp
This class implements a fully compliant Engine.IO web server with support
for websocket and long\-polling transports.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBasync_mode\fP \-\- The asynchronous model to use. See the Deployment
section in the documentation for a description of the
available options. Valid async modes are "threading",
"eventlet", "gevent" and "gevent_uwsgi". If this
argument is not given, "eventlet" is tried first, then
"gevent_uwsgi", then "gevent", and finally "threading".
The first async mode that has all its dependencies
installed is the one that is chosen.
.IP \(bu 2
\fBping_timeout\fP \-\- The time in seconds that the client waits for the
server to respond before disconnecting. The default
is 60 seconds.
.IP \(bu 2
\fBping_interval\fP \-\- The interval in seconds at which the client pings
the server. The default is 25 seconds. For advanced
control, a two element tuple can be given, where
the first number is the ping interval and the second
is a grace period added by the server. The default
grace period is 5 seconds.
.IP \(bu 2
\fBmax_http_buffer_size\fP \-\- The maximum size of a message when using the
polling transport. The default is 100,000,000
bytes.
.IP \(bu 2
\fBallow_upgrades\fP \-\- Whether to allow transport upgrades or not. The
default is \fBTrue\fP\&.
.IP \(bu 2
\fBhttp_compression\fP \-\- Whether to compress packages when using the
polling transport. The default is \fBTrue\fP\&.
.IP \(bu 2
\fBcompression_threshold\fP \-\- Only compress messages when their byte size
is greater than this value. The default is
1024 bytes.
.IP \(bu 2
\fBcookie\fP \-\- Name of the HTTP cookie that contains the client session
id. If set to \fBNone\fP, a cookie is not sent to the client.
The default is \fB\(aqio\(aq\fP\&.
.IP \(bu 2
\fBcors_allowed_origins\fP \-\- Origin or list of origins that are allowed to
connect to this server. Only the same origin
is allowed by default. Set this argument to
\fB\(aq*\(aq\fP to allow all origins, or to \fB[]\fP to
disable CORS handling.
.IP \(bu 2
\fBcors_credentials\fP \-\- Whether credentials (cookies, authentication) are
allowed in requests to this server. The default
is \fBTrue\fP\&.
.IP \(bu 2
\fBlogger\fP \-\- To enable logging set to \fBTrue\fP or pass a logger object to
use. To disable logging set to \fBFalse\fP\&. The default is
\fBFalse\fP\&.
.IP \(bu 2
\fBjson\fP \-\- An alternative json module to use for encoding and decoding
packets. Custom json modules must have \fBdumps\fP and \fBloads\fP
functions that are compatible with the standard library
versions.
.IP \(bu 2
\fBasync_handlers\fP \-\- If set to \fBTrue\fP, run message event handlers in
non\-blocking threads. To run handlers synchronously,
set to \fBFalse\fP\&. The default is \fBTrue\fP\&.
.IP \(bu 2
\fBmonitor_clients\fP \-\- If set to \fBTrue\fP, a background task will ensure
inactive clients are closed. Set to \fBFalse\fP to
disable the monitoring task (not recommended). The
default is \fBTrue\fP\&.
.IP \(bu 2
\fBkwargs\fP \-\- Reserved for future extensions, any additional parameters
given as keyword arguments will be silently ignored.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B create_event(*args, **kwargs)
Create an event object using the appropriate async model.
.sp
This is a utility function that applications can use to create an
event without having to worry about using the correct call for the
selected async mode.
.UNINDENT
.INDENT 7.0
.TP
.B create_queue(*args, **kwargs)
Create a queue object using the appropriate async model.
.sp
This is a utility function that applications can use to create a queue
without having to worry about using the correct call for the selected
async mode.
.UNINDENT
.INDENT 7.0
.TP
.B disconnect(sid=None)
Disconnect a client.
.INDENT 7.0
.TP
.B Parameters
\fBsid\fP \-\- The session id of the client to close. If this parameter
is not given, then all clients are closed.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B get_queue_empty_exception()
Return the queue empty exception for the appropriate async model.
.sp
This is a utility function that applications can use to work with a
queue without having to worry about using the correct call for the
selected async mode.
.UNINDENT
.INDENT 7.0
.TP
.B get_session(sid)
Return the user session for a client.
.INDENT 7.0
.TP
.B Parameters
\fBsid\fP \-\- The session id of the client.
.UNINDENT
.sp
The return value is a dictionary. Modifications made to this
dictionary are not guaranteed to be preserved unless
\fBsave_session()\fP is called, or when the \fBsession\fP context manager
is used.
.UNINDENT
.INDENT 7.0
.TP
.B handle_request(environ, start_response)
Handle an HTTP request from the client.
.sp
This is the entry point of the Engine.IO application, using the same
interface as a WSGI application. For the typical usage, this function
is invoked by the \fI\%Middleware\fP instance, but it can be invoked
directly when the middleware is not used.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBenviron\fP \-\- The WSGI environment.
.IP \(bu 2
\fBstart_response\fP \-\- The WSGI \fBstart_response\fP function.
.UNINDENT
.UNINDENT
.sp
This function returns the HTTP response body to deliver to the client
as a byte sequence.
.UNINDENT
.INDENT 7.0
.TP
.B on(event, handler=None)
Register an event handler.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBevent\fP \-\- The event name. Can be \fB\(aqconnect\(aq\fP, \fB\(aqmessage\(aq\fP or
\fB\(aqdisconnect\(aq\fP\&.
.IP \(bu 2
\fBhandler\fP \-\- The function that should be invoked to handle the
event. When this parameter is not given, the method
acts as a decorator for the handler function.
.UNINDENT
.UNINDENT
.sp
Example usage:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
# as a decorator:
@eio.on(\(aqconnect\(aq)
def connect_handler(sid, environ):
    print(\(aqConnection request\(aq)
    if environ[\(aqREMOTE_ADDR\(aq] in blacklisted:
        return False  # reject

# as a method:
def message_handler(sid, msg):
    print(\(aqReceived message: \(aq, msg)
    eio.send(sid, \(aqresponse\(aq)
eio.on(\(aqmessage\(aq, message_handler)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The handler function receives the \fBsid\fP (session ID) for the
client as first argument. The \fB\(aqconnect\(aq\fP event handler receives the
WSGI environment as a second argument, and can return \fBFalse\fP to
reject the connection. The \fB\(aqmessage\(aq\fP handler receives the message
payload as a second argument. The \fB\(aqdisconnect\(aq\fP handler does not
take a second argument.
.UNINDENT
.INDENT 7.0
.TP
.B save_session(sid, session)
Store the user session for a client.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsid\fP \-\- The session id of the client.
.IP \(bu 2
\fBsession\fP \-\- The session dictionary.
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B send(sid, data, binary=None)
Send a message to a client.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsid\fP \-\- The session id of the recipient client.
.IP \(bu 2
\fBdata\fP \-\- The data to send to the client. Data can be of type
\fBstr\fP, \fBbytes\fP, \fBlist\fP or \fBdict\fP\&. If a \fBlist\fP
or \fBdict\fP, the data will be serialized as JSON.
.IP \(bu 2
\fBbinary\fP \-\- \fBTrue\fP to send packet as binary, \fBFalse\fP to send
as text. If not given, unicode (Python 2) and str
(Python 3) are sent as text, and str (Python 2) and
bytes (Python 3) are sent as binary.
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B session(sid)
Return the user session for a client with context manager syntax.
.INDENT 7.0
.TP
.B Parameters
\fBsid\fP \-\- The session id of the client.
.UNINDENT
.sp
This is a context manager that returns the user session dictionary for
the client. Any changes that are made to this dictionary inside the
context manager block are saved back to the session. Example usage:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
@eio.on(\(aqconnect\(aq)
def on_connect(sid, environ):
    username = authenticate_user(environ)
    if not username:
        return False
    with eio.session(sid) as session:
        session[\(aqusername\(aq] = username

@eio.on(\(aqmessage\(aq)
def on_message(sid, msg):
    with eio.session(sid) as session:
        print(\(aqreceived message from \(aq, session[\(aqusername\(aq])
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B sleep(seconds=0)
Sleep for the requested amount of time using the appropriate async
model.
.sp
This is a utility function that applications can use to put a task to
sleep without having to worry about using the correct call for the
selected async mode.
.UNINDENT
.INDENT 7.0
.TP
.B start_background_task(target, *args, **kwargs)
Start a background task using the appropriate async model.
.sp
This is a utility function that applications can use to start a
background task using the method that is compatible with the
selected async mode.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBtarget\fP \-\- the target function to execute.
.IP \(bu 2
\fBargs\fP \-\- arguments to pass to the function.
.IP \(bu 2
\fBkwargs\fP \-\- keyword arguments to pass to the function.
.UNINDENT
.UNINDENT
.sp
This function returns an object compatible with the \fIThread\fP class in
the Python standard library. The \fIstart()\fP method on this object is
already called by this function.
.UNINDENT
.INDENT 7.0
.TP
.B transport(sid)
Return the name of the transport used by the client.
.sp
The two possible values returned by this function are \fB\(aqpolling\(aq\fP
and \fB\(aqwebsocket\(aq\fP\&.
.INDENT 7.0
.TP
.B Parameters
\fBsid\fP \-\- The session of the client.
.UNINDENT
.UNINDENT
.UNINDENT
.SS \fBAsyncServer\fP class
.INDENT 0.0
.TP
.B class engineio.AsyncServer(async_mode=None, ping_timeout=60, ping_interval=25, max_http_buffer_size=100000000, allow_upgrades=True, http_compression=True, compression_threshold=1024, cookie=\(aqio\(aq, cors_allowed_origins=None, cors_credentials=True, logger=False, json=None, async_handlers=True, monitor_clients=None, **kwargs)
An Engine.IO server for asyncio.
.sp
This class implements a fully compliant Engine.IO web server with support
for websocket and long\-polling transports, compatible with the asyncio
framework on Python 3.5 or newer.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBasync_mode\fP \-\- The asynchronous model to use. See the Deployment
section in the documentation for a description of the
available options. Valid async modes are "aiohttp",
"sanic", "tornado" and "asgi". If this argument is not
given, "aiohttp" is tried first, followed by "sanic",
"tornado", and finally "asgi". The first async mode that
has all its dependencies installed is the one that is
chosen.
.IP \(bu 2
\fBping_timeout\fP \-\- The time in seconds that the client waits for the
server to respond before disconnecting.
.IP \(bu 2
\fBping_interval\fP \-\- The interval in seconds at which the client pings
the server. The default is 25 seconds. For advanced
control, a two element tuple can be given, where
the first number is the ping interval and the second
is a grace period added by the server. The default
grace period is 5 seconds.
.IP \(bu 2
\fBmax_http_buffer_size\fP \-\- The maximum size of a message when using the
polling transport.
.IP \(bu 2
\fBallow_upgrades\fP \-\- Whether to allow transport upgrades or not.
.IP \(bu 2
\fBhttp_compression\fP \-\- Whether to compress packages when using the
polling transport.
.IP \(bu 2
\fBcompression_threshold\fP \-\- Only compress messages when their byte size
is greater than this value.
.IP \(bu 2
\fBcookie\fP \-\- Name of the HTTP cookie that contains the client session
id. If set to \fBNone\fP, a cookie is not sent to the client.
.IP \(bu 2
\fBcors_allowed_origins\fP \-\- Origin or list of origins that are allowed to
connect to this server. Only the same origin
is allowed by default. Set this argument to
\fB\(aq*\(aq\fP to allow all origins, or to \fB[]\fP to
disable CORS handling.
.IP \(bu 2
\fBcors_credentials\fP \-\- Whether credentials (cookies, authentication) are
allowed in requests to this server.
.IP \(bu 2
\fBlogger\fP \-\- To enable logging set to \fBTrue\fP or pass a logger object to
use. To disable logging set to \fBFalse\fP\&.
.IP \(bu 2
\fBjson\fP \-\- An alternative json module to use for encoding and decoding
packets. Custom json modules must have \fBdumps\fP and \fBloads\fP
functions that are compatible with the standard library
versions.
.IP \(bu 2
\fBasync_handlers\fP \-\- If set to \fBTrue\fP, run message event handlers in
non\-blocking threads. To run handlers synchronously,
set to \fBFalse\fP\&. The default is \fBTrue\fP\&.
.IP \(bu 2
\fBkwargs\fP \-\- Reserved for future extensions, any additional parameters
given as keyword arguments will be silently ignored.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B attach(app, engineio_path=\(aqengine.io\(aq)
Attach the Engine.IO server to an application.
.UNINDENT
.INDENT 7.0
.TP
.B create_event(*args, **kwargs)
Create an event object using the appropriate async model.
.sp
This is a utility function that applications can use to create an
event without having to worry about using the correct call for the
selected async mode. For asyncio based async modes, this returns
an instance of \fBasyncio.Event\fP\&.
.UNINDENT
.INDENT 7.0
.TP
.B create_queue(*args, **kwargs)
Create a queue object using the appropriate async model.
.sp
This is a utility function that applications can use to create a queue
without having to worry about using the correct call for the selected
async mode. For asyncio based async modes, this returns an instance of
\fBasyncio.Queue\fP\&.
.UNINDENT
.INDENT 7.0
.TP
.B disconnect(sid=None)
Disconnect a client.
.INDENT 7.0
.TP
.B Parameters
\fBsid\fP \-\- The session id of the client to close. If this parameter
is not given, then all clients are closed.
.UNINDENT
.sp
Note: this method is a coroutine.
.UNINDENT
.INDENT 7.0
.TP
.B get_queue_empty_exception()
Return the queue empty exception for the appropriate async model.
.sp
This is a utility function that applications can use to work with a
queue without having to worry about using the correct call for the
selected async mode. For asyncio based async modes, this returns an
instance of \fBasyncio.QueueEmpty\fP\&.
.UNINDENT
.INDENT 7.0
.TP
.B get_session(sid)
Return the user session for a client.
.INDENT 7.0
.TP
.B Parameters
\fBsid\fP \-\- The session id of the client.
.UNINDENT
.sp
The return value is a dictionary. Modifications made to this
dictionary are not guaranteed to be preserved. If you want to modify
the user session, use the \fBsession\fP context manager instead.
.UNINDENT
.INDENT 7.0
.TP
.B handle_request(*args, **kwargs)
Handle an HTTP request from the client.
.sp
This is the entry point of the Engine.IO application. This function
returns the HTTP response to deliver to the client.
.sp
Note: this method is a coroutine.
.UNINDENT
.INDENT 7.0
.TP
.B on(event, handler=None)
Register an event handler.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBevent\fP \-\- The event name. Can be \fB\(aqconnect\(aq\fP, \fB\(aqmessage\(aq\fP or
\fB\(aqdisconnect\(aq\fP\&.
.IP \(bu 2
\fBhandler\fP \-\- The function that should be invoked to handle the
event. When this parameter is not given, the method
acts as a decorator for the handler function.
.UNINDENT
.UNINDENT
.sp
Example usage:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
# as a decorator:
@eio.on(\(aqconnect\(aq)
def connect_handler(sid, environ):
    print(\(aqConnection request\(aq)
    if environ[\(aqREMOTE_ADDR\(aq] in blacklisted:
        return False  # reject

# as a method:
def message_handler(sid, msg):
    print(\(aqReceived message: \(aq, msg)
    eio.send(sid, \(aqresponse\(aq)
eio.on(\(aqmessage\(aq, message_handler)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The handler function receives the \fBsid\fP (session ID) for the
client as first argument. The \fB\(aqconnect\(aq\fP event handler receives the
WSGI environment as a second argument, and can return \fBFalse\fP to
reject the connection. The \fB\(aqmessage\(aq\fP handler receives the message
payload as a second argument. The \fB\(aqdisconnect\(aq\fP handler does not
take a second argument.
.UNINDENT
.INDENT 7.0
.TP
.B save_session(sid, session)
Store the user session for a client.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsid\fP \-\- The session id of the client.
.IP \(bu 2
\fBsession\fP \-\- The session dictionary.
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B send(sid, data, binary=None)
Send a message to a client.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsid\fP \-\- The session id of the recipient client.
.IP \(bu 2
\fBdata\fP \-\- The data to send to the client. Data can be of type
\fBstr\fP, \fBbytes\fP, \fBlist\fP or \fBdict\fP\&. If a \fBlist\fP
or \fBdict\fP, the data will be serialized as JSON.
.IP \(bu 2
\fBbinary\fP \-\- \fBTrue\fP to send packet as binary, \fBFalse\fP to send
as text. If not given, unicode (Python 2) and str
(Python 3) are sent as text, and str (Python 2) and
bytes (Python 3) are sent as binary.
.UNINDENT
.UNINDENT
.sp
Note: this method is a coroutine.
.UNINDENT
.INDENT 7.0
.TP
.B session(sid)
Return the user session for a client with context manager syntax.
.INDENT 7.0
.TP
.B Parameters
\fBsid\fP \-\- The session id of the client.
.UNINDENT
.sp
This is a context manager that returns the user session dictionary for
the client. Any changes that are made to this dictionary inside the
context manager block are saved back to the session. Example usage:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
@eio.on(\(aqconnect\(aq)
def on_connect(sid, environ):
    username = authenticate_user(environ)
    if not username:
        return False
    with eio.session(sid) as session:
        session[\(aqusername\(aq] = username

@eio.on(\(aqmessage\(aq)
def on_message(sid, msg):
    async with eio.session(sid) as session:
        print(\(aqreceived message from \(aq, session[\(aqusername\(aq])
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B sleep(seconds=0)
Sleep for the requested amount of time using the appropriate async
model.
.sp
This is a utility function that applications can use to put a task to
sleep without having to worry about using the correct call for the
selected async mode.
.sp
Note: this method is a coroutine.
.UNINDENT
.INDENT 7.0
.TP
.B start_background_task(target, *args, **kwargs)
Start a background task using the appropriate async model.
.sp
This is a utility function that applications can use to start a
background task using the method that is compatible with the
selected async mode.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBtarget\fP \-\- the target function to execute.
.IP \(bu 2
\fBargs\fP \-\- arguments to pass to the function.
.IP \(bu 2
\fBkwargs\fP \-\- keyword arguments to pass to the function.
.UNINDENT
.UNINDENT
.sp
The return value is a \fBasyncio.Task\fP object.
.UNINDENT
.INDENT 7.0
.TP
.B transport(sid)
Return the name of the transport used by the client.
.sp
The two possible values returned by this function are \fB\(aqpolling\(aq\fP
and \fB\(aqwebsocket\(aq\fP\&.
.INDENT 7.0
.TP
.B Parameters
\fBsid\fP \-\- The session of the client.
.UNINDENT
.UNINDENT
.UNINDENT
.SS \fBWSGIApp\fP class
.INDENT 0.0
.TP
.B class engineio.WSGIApp(engineio_app, wsgi_app=None, static_files=None, engineio_path=\(aqengine.io\(aq)
WSGI application middleware for Engine.IO.
.sp
This middleware dispatches traffic to an Engine.IO application. It can
also serve a list of static files to the client, or forward unrelated
HTTP traffic to another WSGI application.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBengineio_app\fP \-\- The Engine.IO server. Must be an instance of the
\fBengineio.Server\fP class.
.IP \(bu 2
\fBwsgi_app\fP \-\- The WSGI app that receives all other traffic.
.IP \(bu 2
\fBstatic_files\fP \-\- A dictionary with static file mapping rules. See the
documentation for details on this argument.
.IP \(bu 2
\fBengineio_path\fP \-\- The endpoint where the Engine.IO application should
be installed. The default value is appropriate for
most cases.
.UNINDENT
.UNINDENT
.sp
Example usage:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
import engineio
import eventlet

eio = engineio.Server()
app = engineio.WSGIApp(eio, static_files={
    \(aq/\(aq: {\(aqcontent_type\(aq: \(aqtext/html\(aq, \(aqfilename\(aq: \(aqindex.html\(aq},
    \(aq/index.html\(aq: {\(aqcontent_type\(aq: \(aqtext/html\(aq,
                    \(aqfilename\(aq: \(aqindex.html\(aq},
})
eventlet.wsgi.server(eventlet.listen((\(aq\(aq, 8000)), app)
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.SS \fBASGIApp\fP class
.INDENT 0.0
.TP
.B class engineio.ASGIApp(engineio_server, other_asgi_app=None, static_files=None, engineio_path=\(aqengine.io\(aq)
ASGI application middleware for Engine.IO.
.sp
This middleware dispatches traffic to an Engine.IO application. It can
also serve a list of static files to the client, or forward unrelated
HTTP traffic to another ASGI application.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBengineio_server\fP \-\- The Engine.IO server. Must be an instance of the
\fBengineio.AsyncServer\fP class.
.IP \(bu 2
\fBstatic_files\fP \-\- A dictionary with static file mapping rules. See the
documentation for details on this argument.
.IP \(bu 2
\fBother_asgi_app\fP \-\- A separate ASGI app that receives all other traffic.
.IP \(bu 2
\fBengineio_path\fP \-\- The endpoint where the Engine.IO application should
be installed. The default value is appropriate for
most cases.
.UNINDENT
.UNINDENT
.sp
Example usage:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
import engineio
import uvicorn

eio = engineio.AsyncServer()
app = engineio.ASGIApp(eio, static_files={
    \(aq/\(aq: {\(aqcontent_type\(aq: \(aqtext/html\(aq, \(aqfilename\(aq: \(aqindex.html\(aq},
    \(aq/index.html\(aq: {\(aqcontent_type\(aq: \(aqtext/html\(aq,
                    \(aqfilename\(aq: \(aqindex.html\(aq},
})
uvicorn.run(app, \(aq127.0.0.1\(aq, 5000)
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.SS \fBMiddleware\fP class (deprecated)
.INDENT 0.0
.TP
.B class engineio.Middleware(engineio_app, wsgi_app=None, engineio_path=\(aqengine.io\(aq)
This class has been renamed to \fBWSGIApp\fP and is now deprecated.
.UNINDENT
.INDENT 0.0
.IP \(bu 2
genindex
.IP \(bu 2
modindex
.IP \(bu 2
search
.UNINDENT
.SH AUTHOR
Miguel Grinberg
.SH COPYRIGHT
2018, Miguel Grinberg
.\" Generated by docutils manpage writer.
.
